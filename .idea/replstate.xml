<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1441439937738">{:repl-history {:ide [], :local [&quot;(ns chat-server.handler\n  (:require [ring.middleware.json :refer [wrap-json-response wrap-json-body]]\n           [ring.util.response :refer [response]]\n            [compojure.handler :as handler]))&quot; &quot;(ns chat-server.handler\n  (:require [ring.middleware.json :refer [wrap-json-response wrap-json-body]]\n           [ring.util.response :refer [response]]\n            [compojure.handler :as handler]\n            [compojure.core :refer [routes]]))&quot; &quot;(ns chat-server.handler\n  (:require [ring.middleware.json :refer [wrap-json-response wrap-json-body]]\n           [ring.util.response :refer [response]]\n            [compojure.handler :as handler]\n            [compojure.core :refer [routes]]\n            [chat-server.routes.home :refer [home-routes]]\n            [chat-server.routes.websocket :refer [websocket-routes]]))&quot; &quot;(def app\n  (-&gt; (handler/site (routes home-routes websocket-routes))\n      wrap-base-url\n      wrap-json-body\n      wrap-json-response))&quot; &quot;(def app\n  (-&gt; (handler/site (routes home-routes websocket-routes))\n      wrap-json-body\n      wrap-json-response))&quot; &quot;(ns chat-server.core\n  (:require [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [chat-server.handler :refer [app]])\n  (:gen-class))&quot; &quot;(defn -main [&amp; args]\n  (let [port (parse-port args)]\n    (.addShutdownHook (Runtime/getRuntime) (Thread. stop-server))\n    (start-server port)\n    (timbre/info \&quot;server started on port:\&quot; port)\n    ))&quot; &quot;(def app\n  (routes home-routes websocket-routes))&quot; &quot;(defroutes websocket-routes\n           (GET \&quot;/ws\&quot; req (websocket-handler req)))&quot; &quot;(defn websocket-handler [req]\n  (server/with-channel req channel\n                       (let [msg (read-json (:body req))\n                             to (:to msg)\n                             msg-type (to-msg-type to)]\n                         (if (validate-request req)\n                           (do\n                             (connect! channel to)\n                             (server/on-close channel (partial disconnect! channel to))\n                             (server/on-receive channel\n                                                (cond\n                                                  (= msg-type :world)\n                                                  (fn [msg]\n                                                    (server/send! channel msg)\n                                                    ())\n\n                                                  ;(= msg-type :chatroom) ...\n                                                  ;(= msg-type :p2p) ...)\n                                                ))\n                           (server/send! channel (json-str {:error true :reason \&quot;用户名,密码验证不正确.\&quot;})))))))&quot; &quot;(def users (atom []))&quot; &quot;(def u (-&gt;User \&quot;a\&quot; \&quot;123\&quot; [\&quot;b\&quot;]))&quot; &quot;(map-&gt;User {:name \&quot;a\&quot; :encrypted-password \&quot;123\&quot;})&quot; &quot;(map-&gt;Message {:from \&quot;1\&quot;})&quot; &quot;(ns chat-server.routes.websocket\n  (:require [compojure.core :refer [defroutes GET POST context]]\n            [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [buddy.hashers :as hashers]\n            [clojure.data.json :refer [json-str read-json]]\n            [clj-time.core :as t]\n            )\n  (:use chat-server.models))&quot; &quot;(ns chat-server.core\n  (:require [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [chat-server.handler :refer [app]])\n  (:require [chat-server.routes.websocket :refer [msgs-world msgs-chatroom msgs-p2p]])\n  (:gen-class))&quot; &quot;(ns chat-server.core\n  (:require [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [chat-server.handler :refer [app]]\n            [clj-time.core :as t])\n  (:require [chat-server.routes.websocket :refer [msgs-world msgs-chatroom msgs-p2p]])\n  (:gen-class))&quot; &quot;(t/now)&quot; &quot;(t/minutes 5)&quot; &quot;(t/after (t/now) (t/plus (t/now) (t/minutes 5)))&quot; &quot;(t/after? (t/now) (t/plus (t/now) (t/minutes 5)))&quot; &quot;(t/after? (t/plus (t/now) (t/minutes 5)) (t/now))&quot; &quot;(defn clean-msgs [msgs-location]\n  (doseq [m @msgs-location]\n    (if (t/after? (t/now) (t/plus (:time m) (t/minutes 5)))\n      (swap! msgs-location disj m))))&quot; &quot;(defn start-clean-task []\n  (future\n    (loop []\n      (clean-msgs msgs-world)\n      (clean-msgs msgs-chatroom)\n      (Thread/sleep (* 5 60 1000))\n      (recur))))&quot; &quot;(defn -main [&amp; args]\n  (let [port (parse-port args)]\n    (.addShutdownHook (Runtime/getRuntime) (Thread. stop-server))\n    (start-server port)\n    (start-clean-task)\n    (timbre/info \&quot;server started on port:\&quot; port)\n    ))&quot; &quot;(defn clean-msgs [msgs-location]\n  \&quot;Clean msgs in atom msg-location,msg is instance of Message,msg-location is (atom #{...}),return the changed atom.\&quot;\n  (doseq [m @msgs-location]\n    (if (t/after? (t/now) (t/plus (:time m) (t/minutes 5)))\n      (swap! msgs-location disj m)))\n  msgs-location)&quot; &quot;(ns chat-server.routes.websocket\n  (:require [compojure.core :refer [defroutes GET POST context]]\n            [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [buddy.hashers :as hashers]\n            [clojure.data.json :refer [json-str read-json]]\n            [clj-time.core :as t]\n            )\n  (:use chat-server.models)\n  (:require [chat-server.core :refer [clean-msgs]]\n    ))&quot; &quot;(defroutes api-routes\n           (context \&quot;/api\&quot; []\n             (GET \&quot;/world-records\&quot; (clean-msgs msgs-world))))&quot; &quot;(defroutes api-routes\n           (context \&quot;/api\&quot; []\n             (GET \&quot;/world-records\&quot; []  (clean-msgs msgs-world))))&quot; &quot;*ns*&quot; &quot;(clean-msgs msgs-world\n            )&quot; &quot;(json-str #{1 2 })&quot; &quot;(read-json *1)&quot; &quot;(defroutes api-routes\n           (context \&quot;/api\&quot; []\n             (GET \&quot;/world-records\&quot; [] (json-str (deref (clean-msgs msgs-world))))\n             (GET \&quot;/chatroom-records\&quot; [] (json-str (deref (clean-msgs msgs-chatroom))))))&quot; &quot;(api-routes)&quot; &quot;api-routes&quot; &quot;(-&gt;User)&quot; &quot;(map-&gt;User)&quot; &quot;(conj nil 1)&quot; &quot;#{1 2} 1&quot; &quot;(#{1 2} 1)&quot; &quot;(filter #(= 1 %) #{1 2})&quot; &quot;(defn websocket-handler [req]\n  (server/with-channel req channel\n                       (let [msg (read-json (:body req))\n                             to (:to msg)\n                             msg-type (to-msg-type to)]\n                         (if (validate-request req)\n                           (do\n                             (connect! channel to)\n                             (server/on-close channel (partial disconnect! channel to))\n                             (server/on-receive channel\n                                                (cond\n                                                  (= msg-type :world)\n                                                  (fn [msg]\n                                                    (server/send! channel msg)\n                                                    (swap! msgs-world conj (Message-from-map msg)))\n\n                                                  (= msg-type :chatroom)\n                                                  (fn [msg]\n                                                    (server/send! channel msg)\n                                                    (swap! msgs-chatroom conj (Message-from-map msg)))\n\n                                                  (= msg-type :p2p)\n                                                  (fn [msg]\n                                                    (server/send! channel msg)\n                                                    ;;msg中的to存到users的from(User对象的)的talked-persons-history中\n                                                    ;;以便请求点对点聊天过的好友列表时用.\n                                                    (swap! users conj (map-&gt;User {:id (next-id)\n                                                                                  :name (:from msg)\n                                                                                 :encrypted-password (-&gt; req :params :password)\n                                                                                 :talked-person-history\n                                                                                 (let [origin-history (:talked-person-history (select-keys))])}))\n                                                    (swap! msgs-p2p conj (Message-from-map msg))))\n                                                ))\n                           (server/send! channel (json-str {:error true :reason \&quot;用户名,密码验证不正确.\&quot;}))))))&quot; &quot;(let [id 0]\n  (defn next-id []\n    (ind id)))&quot; &quot;(let [id 0]\n  (defn next-id []\n    (inc id)))&quot; &quot;(let [id (atom 0)]\n  (defn next-id []\n    (swap! id inc)\n    @id))&quot; &quot;(next-id)&quot; &quot;(use 'clojure.dir)&quot; &quot;(use 'clojure.repl)&quot; &quot;(apropos \&quot;unique\&quot;)&quot; &quot;(find-doc \&quot;unique\&quot;)&quot; &quot;(sort-by :name #{{:name 1} {:name 3} {:name 2}})&quot; &quot;(def m {:name \&quot;a\&quot; :age 1})&quot; &quot;(defrecord Person [name age])&quot; &quot;(= m (map-&gt;Person m))&quot; &quot;(= (map-&gt;Person m) (map-&gt;Person m))&quot; &quot;(update-in (map-&gt;Person m) [:name] (str dd))&quot; &quot;(update-in (map-&gt;Person m) [:name] (str 'dd))&quot; &quot;(update-in (map-&gt;Person m) [:name] #(str % 'dd))&quot; &quot;(defn get-latest-message-text [from to]\n  (last (sort-by :time \n                 (filter #(and (= from (:from %))\n                               (= to   (:to %)))\n                         @msgs-p2p))))&quot; &quot;(sorted-map [1 2 3])&quot; &quot;(apply sorted-map [1 2 3])&quot; &quot;(def chatrooms (atom []))&quot; &quot;[chatroom (first (filter #(= chatroom-id (:chatroom-id %)) @chatrooms))\n        owner (:chatroom-owner chatroom)\n        guests (:chatroom-guests chatroom)]&quot; &quot;(map-indexed #(%1 %2) [\&quot;a\&quot; \&quot;B\&quot;])&quot; &quot;(map-indexed #([%1 %2]) [\&quot;a\&quot; \&quot;b\&quot;])&quot; &quot;(map-indexed (fn [index e] [index e]) \&quot;abc\&quot;)&quot; &quot;(update-in {:a {:b 2}} [:a :b] 3)&quot; &quot;(update-in {:a {:b 2}} [:a :b] #(str %))&quot; &quot;(assoc-in {:a {:b 2}} [:a :b] 3)&quot; &quot;(defn get-chatroom-index [chatroom-id]\n  ((into {} (map-indexed (fn [index ele] [(:chatroom-id ele) index]) @chatrooms)) chatroom-id))&quot; &quot;(defn invite [chatroom-id chatroom-owner chatroom-guest]\n  (swap! chatrooms update-in [(get-chatroom-index chatroom-id) :chatroom-guests] #(conj % chatroom-guest)))&quot; &quot;(vector \&quot;1\&quot; 2\n        )&quot; &quot;(into {} *1)&quot; &quot;(into {} [\&quot;1\&quot; 2])&quot; &quot;(array-map \&quot;1\&quot; 2)&quot; &quot;(json-str '(1 23))&quot; &quot;(key User)&quot; &quot;(keys Users)&quot; &quot;(map-&gt;User {})&quot; &quot;(map-&gt;Message {})&quot; &quot;(defn set-msgs [from to text time should-reserved])&quot; &quot;(defn set-chatroom [chatroom-id chatroom-owner chatroom-guests]\n  (swap! chatrooms conj {:chatroom-id chatroom-id :chatroom-owner chatroom-owner :chatroom-guests chatroom-guests}))&quot; &quot;(defn set-msg-world [from to text time should-reserved]\n  (swap! msgs-world conj (-&gt;Message from to text time should-reserved)))&quot; &quot;(defn set-msg-p2p [from to text time should-reserved]\n  (set-msg-world from to text time should-reserved))&quot; &quot;(defn set-msg [msgs-location from to text time should-reserved]\n  (swap! msgs-location conj (-&gt;Message from to text time should-reserved) ))&quot; &quot;(set-chatrooms \&quot;1\&quot; \&quot;a\&quot; [\&quot;b\&quot;])&quot; &quot;(set-chatroom \&quot;2\&quot; \&quot;a\&quot; nil)&quot; &quot;(set-chatroom \&quot;3\&quot; \&quot;b\&quot; [\&quot;a\&quot; \&quot;c\&quot;])&quot; &quot;(defn validate-chatroom [chatroom-id user-name]\n  (let [chatroom (first (filter #(= chatroom-id (:chatroom-id %)) @chatrooms))\n        owner (:chatroom-owner chatroom)\n        guests (:chatroom-guests chatroom)]\n    (and chatroom\n         (or (= owner user-name)\n             (some #(= % user-name) guests)))))&quot; &quot;(defn -main [&amp; args]\n  (let [port (parse-port args)]\n    (.addShutdownHook (Runtime/getRuntime) (Thread. stop-server))\n    \n    (start-server port)\n    (start-clean-task)\n    (timbre/info \&quot;server started on port:\&quot; port)\n    ))&quot; &quot;(ns chat-server.core\n  (:require [org.httpkit.server :as server]\n            [taoensso.timbre :as timbre]\n            [chat-server.handler :refer [app]]\n            [clj-time.core :as t]\n            [chat-server.routes.websocket :refer [start-clean-task set-data]])\n  (:gen-class))&quot; &quot;(defn set-data []\n  \n  (set-users-data (next-id) \&quot;a\&quot; \&quot;1234567\&quot; [\&quot;b\&quot; \&quot;c\&quot;])\n  (set-users-data (next-id) \&quot;b\&quot; \&quot;1234567\&quot; [])\n  (set-users-data (next-id) \&quot;c\&quot; \&quot;1234567\&quot; [\&quot;a\&quot;])\n\n  (set-msg msgs-world \&quot;a\&quot; :world \&quot;i am a\&quot; (t/now) true)\n  (set-msg msgs-world \&quot;b\&quot; :world \&quot;i am b\&quot; (t/plus (t/now) (t/minutes 1)) true)\n  (set-msg msgs-world \&quot;c\&quot; :world \&quot;i am c\&quot; (t/date-time 2015 9 5) true)\n\n  (set-chatroom \&quot;1\&quot; \&quot;a\&quot; [\&quot;b\&quot;])\n  (set-chatroom \&quot;2\&quot; \&quot;a\&quot; nil)\n  (set-chatroom \&quot;3\&quot; \&quot;b\&quot; [\&quot;a\&quot; \&quot;c\&quot;]))&quot; &quot;(defn -main [&amp; args]\n  (let [port (parse-port args)]\n    (.addShutdownHook (Runtime/getRuntime) (Thread. stop-server))\n    (start-server port)\n    (start-clean-task)\n    (timbre/info \&quot;server started on port:\&quot; port)\n    (set-data)\n    (timbre/info \&quot;simulated data seted.\&quot;)\n    ))&quot; &quot;(ns chat-server.handler\n  (:require [compojure.core :refer [routes]]\n            [chat-server.routes.home :refer [home-routes]]\n            [chat-server.routes.websocket :refer [websocket-routes api-routes]]))&quot; &quot;(def app\n  (routes home-routes websocket-routes api-routes))&quot; &quot;(defroutes api-routes\n           (context \&quot;/api\&quot;\n             (GET \&quot;/world-records\&quot; [] (json-str (deref (clean-msgs msgs-world))))\n             (GET \&quot;/chatroom-records\&quot; [chatroom-id] (json-str (filter #(= chatroom-id (key %)) (deref (clean-msgs msgs-chatroom)))))\n             (GET \&quot;/p2p-records\&quot; [user-id] (json-str (get-p2p-records user-id)))))&quot; &quot;(defroutes api-routes\n           (GET \&quot;/api/world-records\&quot; [] (json-str (deref (clean-msgs msgs-world))))\n           (GET \&quot;/api/chatroom-records\&quot; [chatroom-id] (json-str (filter #(= chatroom-id (key %)) (deref (clean-msgs msgs-chatroom)))))\n           (GET \&quot;/api/p2p-records\&quot; [user-id] (json-str (get-p2p-records user-id))))&quot; &quot;(set-data)&quot; &quot;(set-data\n  )&quot; &quot;(ns chat-server.models)&quot;], :remote []}}</component>
</project>